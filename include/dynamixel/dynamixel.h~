/*
*
*   Author: EARL Technologies
*
*   Created: May 01, 2016
*
*/


#ifndef _DYNAMIXEL_H_
#define _DYNAMIXEL_H_

#include <iostream>
#include <string>
#include <vector>
#include <map>

namespace EARL {
namespace Dynamixel {


#define REG_AX_Model_Number			(0)
#define REG_AX_Firmware_Ver			(2)
#define REG_AX_ID					(3)
#define REG_AX_Baud					(4)
#define REG_AX_Ret_Delay_Time		(5)
#define REG_AX_CW_Ang_Lim			(6)
#define REG_AX_CCW_Ang_Lim			(8)
#define REG_EX106_Drive_Mode		(10)
#define REG_AX_Temp_Lim				(11)
#define REG_AX_Voltage_Lim_Low		(12)
#define REG_AX_Voltage_Lim_Hi		(13)
#define REG_AX_Torque_Max			(14)
#define REG_AX_Stat_Ret_Level		(16)
#define REG_AX_Alarm_LED			(17)
#define REG_AX_Alarm_Shutdown		(18)

#define REG_AX_Torque_EN			(24)
#define REG_AX_LED					(25)
#define REG_AX_CW_Margin			(26)
#define REG_AX_CCW_Margin			(27)
#define REG_AX_CW_Slope				(28)
#define REG_AX_CCW_Slope			(29)
#define REG_AX_Goal_Pos				(30)
#define REG_AX_Goal_Vel				(32)
#define REG_AX_Goal_Torque			(34)
#define REG_AX_Present_Pos			(36)
#define REG_AX_Present_Speed		(38)
#define REG_AX_Present_Load			(40)
#define REG_AX_Present_Voltage		(42)
#define REG_AX_Present_Temp			(43)
#define REG_AX_Registered			(44)
#define REG_AX_Moving				(46)
#define REG_AX_Lock					(47)
#define REG_AX_Punch				(48)

class Motor;

class Register {
public:
	int value;

	Register() : value(-1) {
	}

	Register & operator =(const int & value) {
		this->value = value;
		return *this;
	}

	operator int() {
		return value;
	}
};

class MotorCalibration {
public:


	void setup();

	void convert(double position, unsigned char* buffer);

	double invert(unsigned char* buffer);

	void setOffset(double offset) {
		this->offset = offset;
	}

	void setReverse(bool reversed) {
		this->reverse = reversed;
	}

	MotorCalibration() :  offset(0), reverse(false) {
	}

private:
	double offset;
	bool reverse;

};


class Interface {
public:
	typedef enum {
	    ERR_NONE                = 0,//There is no error
	    COMMAND_UNSUPPORTED     = -1,//The command is unsupported
	    PORT_IS_DISCONNECTED    = -2,//The port is disconnected
	    PACKET_LENGTH_ERR       = -3,//The packet is too short
	    PACKET_CHECKSUM_ERR     = -4,//Bad incoming checksum
	    PACKET_NULL             = -5,//The packet is empty/NULL
	    ERR_BAD_DEVICE_NAME     = -6,//There is no such device type(see com::open(...))
	    DEVICE_OPEN_ERROR       = -7,//Device open error(for usb2ax code)
	    PORT_IS_CLOSED          = -8,//The communcation port is not open
	    ERR_UNKNOWN             = -9 //Unknown error
	 }Status;

public:
	
	static Interface* createInterface(int baud);

	Interface(int baudrate) : currentlyOpen(false){
		baud = baudrate;
	}

	virtual Status openPort(const char * field) = 0;

	virtual void closePort() = 0;

	int baud;

protected:

	bool currentlyOpen;

};

class USB2AX : public Interface {
public:
	USB2AX(int baudrate) : Interface(baudrate), fid(-1) {
	}
	Status openPort(const char * field);//must execute 'sudo usermod -a -G dialout $USERNAME' before this will work, if you have not already added yourself to the dialout group.
	void closePort();
protected:
	int	fid;
};

class Handler{
private:

	std::map<unsigned char, Motor*> dynamixelList;

	Interface* interface;

	bool isBusy;

public:

	Handler();

	~Handler();

	Interface::Status openInterface(const char * field, int baudrate);

	void forceAddDynamixel(unsigned int ID);

	std::map<unsigned char, Motor*> getDynamixels();

protected:

	int baud;
};

class Motor {

	/*friend classes allow us to access'private'... 
	...and 'protected' members of other classes
	*/
	friend class Interface;
	friend class Handler;
	friend class Packet;

public:
	unsigned short getWord(int iReg);

	/*Sets the goal position of a motor
	*/
	void setGoalPosition(double dAngle);

	/*Sets the speed of a motor(in revolutions per minute)
	*/
	void setSpeed(double dSpeed);

private:

	MotorCalibration calibration;

	size_t numberOfRegisters;
	unsigned char * registers;
	unsigned char * registersDesired;

	/*The main place where all of the motor information is stored
	*/
	static std::map<int, Register> register_map;


protected:

};
class Packet {

private:



	void beginPacket(int iID);//the head/header of the packet
	void endPacket();//the foot of the packet

	void setPacketID(int iID);
	void setPacketInstruction(unsigned char ucInstruction);
	void setPacketAddress(int iAddress);
	void setPacketLowHighByte(int iWord);

	int getPacketLowByte(int iWord);
	int getPacketHighByte(int iWord);


	

public:
	std::vector<unsigned char> packet;//the data packet to be sent/received

	Packet(){
	}
	std::vector<unsigned char>& ping(int iID);
	std::vector<unsigned char>& readByte(int iID, int iAddress);//length read = 1
	std::vector<unsigned char>& readWord(int iID, int iAddress);//length read = 2
	std::vector<unsigned char>& writeByte(int iID, int iAddress, int ivalue);//length written = 1
	std::vector<unsigned char>& writeWord(int iID, int iAddress, int ivalue);//length written = 2
	std::vector<unsigned char>& reset(int iID);

	void write(int iID, int iAddress, int ivalue);
	void viewPacket();

protected:
	bool m_bBusInUse;
};
struct DataRange {

	unsigned short reg;
	unsigned short length;

	DataRange(unsigned short reg = 0, unsigned short length = 0) : reg(reg), length(length){
	}
};
unsigned char getChecksum(const unsigned char * pkucBuffer);


}//namespace Dynamixel
}//namespace EARL

#endif//#ifndef _DYNAMIXEL_H_
